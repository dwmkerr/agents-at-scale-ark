# Memory

The `Memory` resource represents persistent storage for converations with agents. It is designed to be agnostic of the backend implementation, meaning that a database, queue or other system can be used.

The backend for a memory resource is an HTTP server that implements the [Memory API Specification](#memory-api-specification).

In time, this resource will also configure how operations such as compaction can be performed. A reference implementation [PostgreSQL Memory](#postgresql-memory) is available.

## Specification

```yaml
apiVersion: ark.mckinsey.com/v1alpha1
kind: Memory
metadata:
  name: postgres-memory
  annotations:
    # Enable event streaming support for this memory service
    ark.mckinsey.com/memory-event-stream-enabled: "true"
spec:
  # The address of the service that handles memory API calls.
  address:
    # A 'value' can be provided to give a specific URL, or a service ref to
    # point to a specific service in the cluster.
    valueFrom:
      # In this example, we point to a deployment of the "Postgres Memory".
      serviceRef:
        name: postgres-memory
        port: 8080
```

### Annotations

- **`ark.mckinsey.com/memory-event-stream-enabled`** - When set to `"true"`, enables event streaming capabilities for this memory service. The service must implement the [Event Streaming API](#event-streaming-api) endpoints to support real-time message delivery during query execution.

## Usage

Memory can be specified in a query resource:

```yaml
apiVersion: ark.mckinsey.com/v1alpha1
kind: Query
metadata:
  name: chat-with-memory
spec:
  input: "What did we discuss earlier?"
  targets:
    - name: my-agent
  memory:
    name: postgres-memory
  # Optional: specify session ID to group related queries
  # If not provided, the query UID is used as session ID
  sessionId: "my-conversation-session"
```

Memory can also be specified via the `fark` CLI:

```bash
fark query --input "Continue our conversation" --session-id "my-conversation-session" my-agent
```

When creating a query in the dashboard it is also possible to specify the memory resource. Note that in the dashbhoard 'chat' window, no memory is used, messages are simply stored client-side as is common for chat applications.


## Memory API Specification

Memory is implemented as a simple HTTP server:

| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/messages` | Store multiple messages |
| GET | `/messages` | Retrieve messages with optional filtering |
| GET | `/sessions` | List all session IDs |
| GET | `/health` | Health check |
| GET | `/stream/{session_id}` | **Optional:** Server-Sent Events stream |
| POST | `/session/{session_id}/complete` | **Optional:** Mark session complete |

### Store Messages

**POST** `/messages`

Request body includes session/query context and message array:

```json
{
  "session_id": "uuid-string",
  "query_id": "query-uuid", 
  "messages": [
    {
      "role": "user",
      "content": "What is the weather like?"
    },
    {
      "role": "assistant", 
      "content": "I don't have access to real-time weather data."
    }
  ]
}
```

### Retrieve Messages

**GET** `/messages?session_id={id}&query_id={id}&limit={n}&offset={n}`

Returns timestamped message records. All parameters optional.
Without session_id, returns all messages with pagination:

```json
{
  "messages": [
    {
      "timestamp": "2024-01-01T12:00:00Z",
      "session_id": "uuid-string",
      "query_id": "query-uuid",
      "message": {
        "role": "user",
        "content": "What is the weather like?"
      }
    }
  ],
  "total": 100,
  "limit": 50,
  "offset": 0
}
```

### List Sessions

**GET** `/sessions`

Returns object with session IDs:

```json
{"sessions": ["session-1", "session-2", "session-3"]}
```

## Event Streaming API

Memory services can optionally implement real-time streaming endpoints for live message delivery during query execution.

### Stream Messages

**GET** `/stream/{session_id}`

Establishes a Server-Sent Events (SSE) connection to stream messages in real-time.

**Query Parameters:**
- `from-beginning=true` - Send all existing messages first, then stream new ones
- `wait-for-session=true` - Wait for session creation if it doesn't exist yet  
- `timeout=30s` - How long to wait for session creation (default 30s)

**Response Format:**
OpenAI-compatible streaming chunks sent as SSE events:

```
event: message
data: {
  "id": "session-uuid",
  "object": "chat.completion.chunk", 
  "created": 1704067200,
  "model": "memory-service",
  "choices": [{
    "index": 0,
    "delta": {
      "content": "Hello world"
    }
  }]
}

```

**Special Events:**
- `[LIVE_MODE]` - Indicates switch from historical to live streaming
- `[STREAM_END]` - Signals completion when session is marked complete

**Example Usage:**
```bash
curl -N "http://memory-service:8080/stream/my-session?from-beginning=true"
```

This enables real-time streaming of agent responses as they're generated, providing immediate feedback to users during long-running queries.

### Complete Session

**POST** `/session/{session_id}/complete`

Marks a session as complete, triggering completion events to all active streaming clients.

**Example Usage:**
```bash
curl -X POST "http://memory-service:8080/session/my-session/complete"
```

**Response:**
```json
{
  "status": "completed", 
  "session": "my-session"
}
```

When a session is marked complete, streaming clients receive a final chunk with `finish_reason: "stop"` followed by the termination marker `data: [DONE]`.

## PostgreSQL Memory

The PostgreSQL memory service can be installed with:

```bash
make postgres-memory-install
```

Crunchy PGO is used to simplfy PostgresSQL management.
