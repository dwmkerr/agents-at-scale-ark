apiVersion: chainsaw.kyverno.io/v1alpha1
kind: Test
metadata:
  name: ark-cluster-memory-streaming
spec:
  timeouts:
    exec: 120s
  description: Test ARK Cluster Memory Streaming Service
  steps:
  - name: setup
    try:
    - script:
        skipLogOutput: true
        content: |
          set -u
          echo "{\"token\": \"$E2E_TEST_AZURE_OPENAI_KEY\", \"url\": \"$E2E_TEST_AZURE_OPENAI_BASE_URL\"}"
        outputs:
        - name: azure
          value: (json_parse($stdout))
    - apply:
        file: manifests/a00-rbac.yaml
    - apply:
        file: manifests/a01-secret.yaml
    - apply:
        file: manifests/a02-model.yaml
    - script:
        skipLogOutput: true
        content: cat test.hurl
        outputs:
        - name: test_script
          value: ($stdout)
    - apply:
        resource:
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: hurl-test-files
          data:
            test.hurl: ($test_script)
    - apply:
        resource:
          apiVersion: v1
          kind: Pod
          metadata:
            name: streaming-test-client
          spec:
            containers:
            - name: hurl
              image: ghcr.io/orange-opensource/hurl:6.1.1
              command: ["sleep", "600"]
              volumeMounts:
              - name: test-files
                mountPath: /tests
            - name: curl
              image: curlimages/curl:latest
              command: ["sleep", "600"]
            volumes:
            - name: test-files
              configMap:
                name: hurl-test-files
            restartPolicy: Never
            terminationGracePeriodSeconds: 0
    - script:
        content: |
          helm install ark-cluster-memory ../chart --wait --timeout=90s \
            --namespace $NAMESPACE \
            --set app.image.repository=${ARK_CLUSTER_MEMORY_IMAGE:-ark-cluster-memory} \
            --set app.image.tag=${ARK_CLUSTER_MEMORY_IMAGE_TAG:-latest}
        env:
        - name: NAMESPACE
          value: ($namespace)
    cleanup:
    - script:
        content: |
          helm uninstall ark-cluster-memory --namespace $NAMESPACE --wait --timeout=30s || true
        env:
        - name: NAMESPACE
          value: ($namespace)

  - name: wait-for-resources
    try:
    - assert:
        resource:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ark-cluster-memory
          status:
            readyReplicas: 1
    - assert:
        resource:
          apiVersion: ark.mckinsey.com/v1alpha1
          kind: Model
          metadata:
            name: test-model
          status:
            phase: ready
    - assert:
        resource:
          apiVersion: ark.mckinsey.com/v1alpha1
          kind: Memory
          metadata:
            name: ark-cluster-memory
          status:
            phase: ready
    - assert:
        resource:
          apiVersion: v1
          kind: Pod
          metadata:
            name: streaming-test-client
          status:
            phase: Running

  # Test basic Hurl HTTP streaming operations first
  - name: run-hurl-tests
    try:
    - script:
        content: |
          kubectl exec streaming-test-client -c hurl -n $NAMESPACE -- hurl --test /tests/test.hurl
        env:
        - name: NAMESPACE
          value: ($namespace)
        timeout: 60s

  # Test Scenario 1: Wait for stream
  - name: test-wait-for-stream
    try:
    - script:
        content: |
          # Start consumer waiting for stream (background process)
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- sh -c '
            curl -N -s -m 30 \
              "http://ark-cluster-memory/stream/streaming-test-wait?from-beginning=true&wait-for-query=30s" \
              > /tmp/stream-wait.txt 2>&1 &
            echo $!
          ' > /tmp/curl-pid.txt

          CURL_PID=$(cat /tmp/curl-pid.txt)
          echo "Started curl process with PID: $CURL_PID"
          sleep 2  # Give curl time to connect

          # Create query after consumer is waiting
          kubectl apply -f manifests/a03-query-wait.yaml -n $NAMESPACE

          # Wait for query to complete
          kubectl wait --for=jsonpath='{.status.phase}'=done \
            query/streaming-test-wait -n $NAMESPACE --timeout=30s

          # Give curl time to receive all data
          sleep 2

          # Check that we received streaming data
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            grep -q "data: \[DONE\]" /tmp/stream-wait.txt || \
            (kubectl exec streaming-test-client -c curl -n $NAMESPACE -- cat /tmp/stream-wait.txt && exit 1)

          # Check stream status
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -s "http://ark-cluster-memory/stream" | \
            jq -e '.queries["streaming-test-wait"].completed == true' || exit 1
        env:
        - name: NAMESPACE
          value: ($namespace)
        timeout: 60s
    catch:
    - events: {}
    - describe:
        apiVersion: ark.mckinsey.com/v1alpha1
        kind: Query
        name: streaming-test-wait

  # Test Scenario 2: Join running stream
  - name: test-join-stream
    try:
    - apply:
        file: manifests/a03-query-join.yaml
    - script:
        content: |
          sleep 1  # Let query start processing

          # Connect to running stream
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -N -s -m 20 \
            "http://ark-cluster-memory/stream/streaming-test-join?from-beginning=true" \
            > /tmp/stream-join.txt

          # Validate we got chunks
          CHUNK_COUNT=$(kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            grep -c "chat.completion.chunk" /tmp/stream-join.txt || echo 0)

          if [ "$CHUNK_COUNT" -eq 0 ]; then
            echo "No chunks received. Stream output:"
            kubectl exec streaming-test-client -c curl -n $NAMESPACE -- cat /tmp/stream-join.txt
            exit 1
          fi

          echo "Received $CHUNK_COUNT chunks"

          # Check stream status
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -s "http://ark-cluster-memory/stream" | \
            jq -e '.queries["streaming-test-join"].completed == true' || exit 1
        env:
        - name: NAMESPACE
          value: ($namespace)
        timeout: 30s
    catch:
    - events: {}
    - describe:
        apiVersion: ark.mckinsey.com/v1alpha1
        kind: Query
        name: streaming-test-join

  # Clean up streams between test groups
  - name: cleanup-streams
    try:
    - script:
        content: |
          # Check total streams before cleanup
          echo "Streams before cleanup:"
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -s "http://ark-cluster-memory/stream" | jq '.total_queries'

          # Purge all streams
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -X DELETE -s "http://ark-cluster-memory/stream" | \
            jq -e '.status == "success"' || exit 1

          # Verify all streams are gone
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -s "http://ark-cluster-memory/stream" | \
            jq -e '.total_queries == 0' || exit 1
        env:
        - name: NAMESPACE
          value: ($namespace)

  # Test Scenario 3: Read completed stream
  - name: test-completed-stream
    try:
    - apply:
        file: manifests/a03-query-completed.yaml
    - assert:
        resource:
          apiVersion: ark.mckinsey.com/v1alpha1
          kind: Query
          metadata:
            name: streaming-test-completed
          status:
            phase: done
    - script:
        content: |
          # Connect to completed query stream
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -N -s -m 10 \
            "http://ark-cluster-memory/stream/streaming-test-completed?from-beginning=true" \
            > /tmp/stream-completed.txt

          # Should get all chunks immediately followed by DONE
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            grep -q "data: \[DONE\]" /tmp/stream-completed.txt || \
            (echo "Missing DONE marker" && exit 1)

          # Verify we got the response about Paris
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            grep -i "paris\|france" /tmp/stream-completed.txt || \
            (echo "Response doesn't mention Paris/France" && exit 1)

          # Final status check
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -s "http://ark-cluster-memory/stream" | \
            jq -e '.queries["streaming-test-completed"].completed == true' || exit 1
        env:
        - name: NAMESPACE
          value: ($namespace)
        timeout: 20s
    catch:
    - events: {}
    - describe:
        apiVersion: ark.mckinsey.com/v1alpha1
        kind: Query
        name: streaming-test-completed

  # Final cleanup
  - name: final-stream-cleanup
    try:
    - script:
        content: |
          # Final purge of all streams
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -X DELETE -s "http://ark-cluster-memory/stream"

          # Verify clean state
          kubectl exec streaming-test-client -c curl -n $NAMESPACE -- \
            curl -s "http://ark-cluster-memory/stream" | \
            jq -e '.total_queries == 0' || exit 1

          echo "All streaming tests completed successfully"
        env:
        - name: NAMESPACE
          value: ($namespace)